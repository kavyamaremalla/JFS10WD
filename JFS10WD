1. tasks from guvi end -> 10-15 tasks, module assessmemt (skill enhancement)
2. mini project, capstone project 
3. assessment

Java Full Stack --> 

backend & front end -> Java
data base -> you store your data (personal & confidential)

Intro to Java. -> web,mobile,desktop apps development,
platform independent -> runs on any OS
OOPS -> follows object oriented programming lang

JVM , JDK, JRE ->

JVM -> load, verfiy, execute code & provide runtime environment
JRE -> implementation of JVM.. libraries + files -> Sun Microsystems
JDK -> JRE + some other tools like javac, java etc..
	Open JDK vs Oracle/Amazon Corretto JDK..
	Javadoc, jar, javac, load java it has tools

JEP -> Java Enhancement Proposal..
	irregular -> Java 6 : 2007, Java 7 : 2011, Java 8 : 2014, Java 9 : 2017.. Java 22 : 2024
	LTS -> java 8, 11, 17, 21 (current lts version)
	every six months i.e., march & september.. minor versions non-lts versions..
	march 12 & sept had java 13.. 12 will be supported until 13 release..

backward compatability ->

Installation of Java & IDE.

	Install JDK -> Amazon Corretto, Oracle or any other provider.. Go with Java 11 or Java 17
		java -version in command prompt
	check environment & system variable -> path to your java.. add JAVA_HOME, also add in path if not present


task : run a java file in your local machine without using an IDE & with using IDE.

Install IDE -> eclipse or sts or IntelliJ or any other tool you wish..

Java Basics :

	class -> blueprint
	object -> car ==> attributes : weight, color., methods/functionx -> drive, brakes
 	
 	Variables : to store data values

 	 //local, global/instance, static

    int price = 700; //instance or global variable

    static int m = 100; // static variable -> memory allocated once when class is loaded in memory

    public static void main(String[] args) {

        Car car = new Car();

        car.price =90; //object-level or instance variable

        int x = 80; //local variable

//        price = 90;
         m = 90;
    }

   public void add(){
        int sum = 100; //local variable
        m = 999;
    }

 	Primitive Data types : byte, short, int, long, float, double, boolean, char
 		-> predefined, immutable, stored in stack memory, store single values

 	Non-primitive	-> stores multiple values, user-defined,  mutable, stored in heap memory
 		String, Array, Object etc

 	Wrapper Classes -> collection, generics, autoboxing -> primitive to wrapper, unboxing is vice versa
 		Integer, Double, Long, Float etc built on primitive data types
 			

 		String -> text in ->  "double quotes"  -> "100 Marks"
 		int -> whole numbers
 		float -> 110.09f
 		char -> character -> 'a' -> one alphabet in single quote
 		boolean -> true/false
 		double val = 190.09; -> 8 bytes of memory
        float flVal = 190.09f; -> 4bytes of memory
        long longVal = 198081893786387457L;; -> 8 bytes of memory
        byte byteVal = 0; -> -128 to 127
        short  shortVal = 100;

        Non-primitive Datatypes: String


 	compile time & run time -> compile == while writing the code, run-time -> when you run/execute the code.


 Type Casting -> converting from one data type to other data type
 
 Example :  Widening & Narrow Casting


        
    //byte < short < char < int < long < float < double

    widening:

        int myInt = 8;
        double myDoubValue = myInt; //Automatic casting

//        System.out.println(myInt);
//        System.out.println(myDoubValue);

	narrow

        double db1 = 9.67d;
        int intVal = (int) db1; // manual cast

        System.out.println(db1);
        System.out.println(intVal);

Operators : Arithmetic, assignment, comparison, logical, bitwise

	 int result = 100 + 700;
        
        String output = "Hi " + "Welcome"; -> concatenation/concatinate

        System.out.println(result);
        System.out.println(output);

     Postfix :
     
      int x = 1, j;
       j = x++;

        System.out.println(j + " " + x );


        logical operators:

      int age = 17;

        System.out.println(age > 18 && age < 100);//false
        System.out.println(age > 18 || age < 100);//true
        System.out.println(!(age > 18 || age < 100));//false   

        Scanner :

         Scanner scanner = new Scanner(System.in);

        System.out.println("Please enter your age ");

        int age = scanner.nextInt();
        

        System.out.println(age > 18 && age < 100);//false
        System.out.println(age > 18 || age < 100);//true
        System.out.println(!(age > 18 || age < 100));//false

Conditional/Control statements: after this terenary operator

Decision -> if/switch -> if, if-else, if & else if, nested if
loop -> while, do while, for, for-each
jump -> break, continue, return

18/07/24 : 

Debugging a class -> scanner and nested-if example.

Naming conventions :

	class -> start with capital letter -> upper camel case 
		SwitchCaseExample
	variable/function/ method name -> starts with small letter
		int age;
		public void sum(){}
	checking account balance method-> checkAccountBalance -> lower camel case
	car -> applyBrakesForCar

Switch :

import java.util.Scanner;

public class SwitchCaseExample {

    public static void main(String[] args) {

        Scanner scanner = new Scanner(System.in);

        System.out.println("Enter day in a week ");
//        char dayOfWeek = scanner.next().charAt(0);

        String dayOfWeek = scanner.next();

        switch (dayOfWeek){
            case "Monday" :
                System.out.println("Day 1");
                break;
            case "Tuesday" :
                add();
                System.out.println("Day 2");
                break;
            case "Wednesday" :
                System.out.println("Day 3");
                break; //keyword
            default:
                System.out.println("Please check your input");
        }


    }

    public static void add(){
        System.out.println("Inside add");
    }
}

For loop :

 System.out.println("Started for loop execution");

        for(int i = 5; i <10; i++){
            System.out.println(i);
        }

        System.out.println("For loop ended");

Nested-for :

    for(int i = 1; i <= 3; i++){ // 1, 2, 3
            for (int j = 1; j <= 3 ; j++) {
                System.out.println(i + " " + j); // 1 1 , 2, 3:::: 2 1 2 3 :::  3, 1, 2, 3
            }// ends i loop
        } // ends j loop        

 int i =3;

        System.out.println(i);
        System.out.println(i++);
        System.out.println(i);
        System.out.println(++i);


for-each/enhanced-for loop : to iterate over collections  


        int arr[] = {1,2,51,62,86,98};

        for(int i : arr){
            System.out.println(i);
        } 

int[] arrayOfNumbers = {1,2,51,62,86,98};

        for(int integerValue : arrayOfNumbers){
            System.out.println(integerValue);
        }


        System.out.println("*******************************************");

        for (int i=0; i < arrayOfNumbers.length ; i++){
            System.out.println(arrayOfNumbers[i]);
        }
 infinite for loop -> 
 
     for( ;  ; ){

            System.out.println("Inside for loop");
        }       

 while loop :
 
  int i = 1;

        while (i< 10){
            System.out.println(i);
            ++i;
        }

do-while loop:

 int i = 1;
       
       do{
           System.out.println(i);
           i++;
       }while (i<=10);


break, return & continue :

  public static void main(String[] args) {
        for (int i = 0; i <=10 ; i++) {
            if(i==5){
//                return;
//                continue;
                break;
            }
            System.out.println(i);
        }

        calculateEngineCC(20);
    }

    public static int calculateEngineCC(int weight){
        int capacity = weight * 1000;
        System.out.println(capacity);
        return capacity;
    }       


Ternary Operator :

 String result = age >= 18 ? "Eligible to vote"  : "Please check next time, not-eligible" ;

 Math Operations

 Literals -> Integer, Character, Boolean, String

 	int price = 750; // 750 -> literal

Main method:

    public static void main(String[] args) {
    }

    public -> to call this method from anywhere by JVM
    static -> can be called without creating an object of the class & memory will be allocated to this..
    void -> no return value to JVM
    main -> name of method
    String[] args -> one argument/parameter of type String array

Git : github, gitlab, bitbucket.. -> distributed version control system

	1. signup
	2. create a repository
	3. add files/folders

Bring from your github account to your local machine :	

git clone https://github.com/kavyamaremalla/JFS10WD.git

Add files to github account : Committing to git

	local ->  staging(temporary storage of files to be committed)  -> github account

git status -> file status 
git add <fileName which you want to send to github account> or for all files -> git add .
git commit -m "Your Message Here : Reason why you are committing" -> local to staging
git push -> from staging to github account

git pull -> changes from github  made by others to be in your local machine


Keywords
	void -> no return type
	static -> memory allocated first to this method

22/7/24 :
Arrays :
Create Arrays :

String[] carBrands = {"Volvo", "Hyundai", "Kia" , String.valueOf(7)};

Integer[] carPrice = {76, 89, 90, 12, Integer.parseInt("45")};

Read Ops on Array:

Index -> position of an element & starts with 0

    array[indexPosition] -> return element in that particular position

    carBrands[4] -> ArrayIndexOutOfBoundsException: Index 4 out of bounds for length 4

    carBrands.length -> length of the array (here it's 4)

    Read an array -> Arrays.toString(carBrands)

    for/for-each on array -> reads elements separately

Update ->

    nameOfArray[indexPositionToUpdate]  = updatedValue

Delete an element from array without conversion to array list.

Removing element from array & insert an element into array without using arraylist

create objects

    1. using new keyword
    2. using new instance
    3. using clone() method
    4. using deserialization
    5. using newInstance() of constructor class

23/07/24    

Access Modifiers -> public, private, protected, default
	- class, method, variables & constructors

package -> group of classes within same space

array sorting -> with and without in-built sort method	
array compares
array equals, fill

Strings : 

	 - charAt(), compareTo(), compareToIgnoreCase(), concat(),contains(), toLowerCase , toUpperCase, equals, endsWith, startsWith, matches, replaces, split, length, split,
	 subString -> string sequence ; subSequence -> CharSequence, toCharArray, toString, String.valueOf, trim

Task :  sort a string array using compareTo

24/07/24

regex, string pool, string builder & buffer, constructors

Regex -> Regular Expression

	. create gmail/email as i/p -> @gmail.com
	. pattern -> capCase, small case, spcl charc, some numbers, min length
		[A-Z], [a-z], [0-9], for not equal to ^ (cap)
		[aA0-zZ9]{3,5}@ -> combined, range
		\d -> decimal
		\D -> non-decimal
		\w -> like combined (decimal & non-deecimal)
		\W -> alpha-numeric
		. -> \w + \W
		.* -> repeatition
		.+ -> match anything

1. define a string pattern
2. compile the string to a regex
3. give i/p
4. match i/p & regex


String -> immutable class
String Builder & String Buffer -> mutable classes

string pool -> Java heap memory storage
	-> .equals checks only value of strings
	-> == checks reference/address/memory of strings

Constructor :
	to initialize the objects
	when you create an object of class, that class's constructor will be called -> default
	parameterized/argumented constructor -> when you send parameters
		-> pass any number of parameters
		-> this keyword

25/07/24:

Oops - Object Oriented Programming
	DRY, Don't Repeat Yourself principle -> reduce repetition of code -> boiler plate code

Encapsulation -> hiding sensitive data from users
	-> variables/methods/attributes will be defined as private
	-> public get and set methods to access and update the private variables

Inheritance(is-a relationship) : getting methods, variables from one class to other class
 	-> subclass (child class) :: the class inherits from another class
 	-> superclass (parent class) :: class which is being inherited
 	keyword -> extends
 	-> multiple inheritance -> one sub class trying to extend more than one super class
 		-> no, java doesn't support multiple inheritance
 			- Diamond problem
 			- complexity.. it should be simple and readable
 	-> can't inherit from a final class
 	Immutable -> other class can't modify attributes, methods etc in a class.
 		-> final keyword at class level -> no other class can extend this immutable class
 		-> declare variables as private and final, only you provide getters	and no setters are declared, provides constructor to initialize the variables
 		***** Once the object is initialized, it can't be modified!	******
	super keyword -> superclass(parent objects)
		-> calls constructor/methods/variables of parent class without creation of object to a parent class
	types : single, multi level, hierarchical, hybrid	

26/07/24 :

	SUPER keyword example -> Person & Employee

Polymorphism
	-> exists in many forms & it occurs when we have many classes that are related to each other by inheritance --> you can do a single action in multiple ways
		. compiletime polymorphism -> method overloading
		. run time polymorphism -> method overriding
	Method overriding -> during run time, jvm determines which method to call
		. from parent, you can create an object of sub class
		. can't override a static method
	@Override -> indicates that a method in a subclass is intended to override a method in parent class
		. if method is not present in parent, but in child if you put @Override it gives you compilation error
		. applicable only on methods not on variables/constructors
		. checks name of parent method and number & type of parameters.. to match with child class
		. improves readability
	Method Overloading -> during compile time, jvm determines which method to call
		. change input parameters data-type (instead of int, double)
		. change number of arguments passed	(instead of 2 int args, 3 int args)
			ambiguity -> if jvm can't determine the type 
				(int, double as i/p params for MethodA & double, int as i/p params for MethodB)
			
29/07/24

Abstraction	-> Data abstraction is called hiding the implementation/logic and showing the essential details
		1. using abstract class -> abstract keyword on classes/methods
			can have both abstract & non-abstract methods
			. class -> restricted class & can't be used to create objects (to use this, we have to inherit this class from another class)
			. method -> can be used only in abstract class and it doesn't have a body. The body will be provided its subclass(inherited class/child classs)
			. abstract is not available at variable level
		2. using interface
			-> completely follows abstract class but, related methods will have empty bodies
			-> implements keyword (child implements methods of parent)
			-> 100% abstraction can be achieved by interface because it doesn't show any logic in normal methods as well (not only abstract class)
			->	by default all methods in an interface are abstract and public.
			-> by default, a variable in an interface is static and final
			->	you can implement multiple interfaces

********* extends -> class level & implements -> interface level ************	
Multi level inheritance is not possible but multiple inhertiance using interface is possible

Enums : enumeration/enumerator

	-> group of constants, can't be changed just like final variables, enum(keyword) is a spcl class
	-> All constants are by default public, static, final

30/07/24 :

Association -> one-to-one, one-to-many, many-to-one, many-to-many relationships/mapping

Aggregation -> has-a relationship	
			bike(child) can exist independently, Vehicle as a parent can't exist independently

Composition : part-of (house and room, house is destroyed -> room will also be destroyed)		

Task : try to get practical example of Association, Aggregation & Composition

Exception handling : Exception hierarchy

technically, throw an exception -> when you expect some error in the program
	can't have multiple try blocks but can have multiple catch blocks -> in single try catch
	finally -> even if try/catch executes or not, this gets executed
	throw(line level) vs throws(method level) -> error handling 
Inbuilt Exception:
	checked vs unchecked -> 
		checked -> exceptions should be handled by user, don't extend runtimeexception
			FileNotFoundException
			throws -> at method level, the method which calls the throws method expects to handle exception either by writing try-catch block or throws exception
				-> suggested to use try-catch
		unchecked -> exceptions jvm handles, these extend runtimeexception
			ArithmeticException

Custom Exception/User-defined exception : we create our own exception
	1. extends exception
	2. calling Parent's constructor from child(user defined exp class) constructor

Collections : framework of Java, which stores/manipulates group of objects.. Collection means a single unit of objects
	-> Book/Coin Collection
	-> it provides interfaces(List, Set, Queue, Dequeue, Map) & classes to perform data operations

Hierarchy : 
Iterable (interface) -> Collection(Interface)
				Under collec -> List (interface) : linkedlist, arraylist..
							-> Queue (interface) -> Dequeue(interface)
							-> Set(interface) -> Sorted set(interface)
							-> Map (interface)
							-> stack
List 

	ArrayList
	-> array vs arrayList : 
		. create an arrayList
		. add elements
		. allows duplicates
		. read using for each loop
		. convert array to list and list to array
		. follows insertion order
		. Collections.sort(nameOfList)	
		. size of arraylist
		. contains -> search an object in an arrayList	
		. remove(index number)	
		. clear / removeAll 
		. add object at particular index position	
		. allows null elements

	Linked List
		. creation
		. adding elements
		. print elements in list using iterator

  //loose coupling & tight coupling
  hash & toString.

  	HashSet -> follows hashing mechanism	
  		. creating & adding elements
  		. allows null values
  		. unique elements, no duplicates
  		. no insertion order, based on hash of objects it inserts & displays the values
  		. removeIf, remove, removeAll
  	LinkedHashSet 
  		. no duplicates allowed
  		. insertion order	
  	TreeSet	
  		. ascending order
  		. no duplicates
  		. no null values allowed
  		. uses comparable, only the comparable objects are allowed
Queue & Priority Queue :	
		. FIFO -> First In First Out
		. create & adding elements to queue
		. read queue
		. stores in ascending order, allows duplicates
		. doesn't allow null
		. pull, element, remove, add, peek

Deque & Array Deque : Double ended queue
		. LIFO -> Last In First Out	 & FIFO -> First In First Out
		. we can add/remove elements from both sides
		. insertion order
		. null values not allowed
		. duplicates are allowed
		. pollFirst, pollLast, removeFirst, removeLast, addFirst, addLast

Stack :
		. LIFO -> Last In First Out		
		. push & pop, top
		. insertion order
		. duplicates & null values are allowed
		. remove, removeAt, add, addAt etc

Map : stores elements on form of key, value pairs called entries.

put, remove, keySet, entrySet, get(key) = value, map.values(), contains, isEmpty, size, replace

	hashMap: internal working of a hashmap

	. keys and values pair
	. no order, based on hashing it gives result
	. duplicates keys are not allowed, duplicate values can be allowed
	. you can update value while creation itself
	. allows null key and null values

	linkedHashMap -> Map + hashmap : allows null key and null values, follows insertion order

	TreeMap -> Map + sorted map : doesn't allow any null keys and null values.

02/08/24 :

toString, hashcode and equals

	toString -> every obj inherits this method through Object.java
	returns string rep of an object
	returns hash of the object

	hashCode -> memory of object

	equals -> override hash and equals

Multithreading :

thread -> extending thread & implementing Runnable/Callable

thread life cycle -> new, run, -> either wait/sleep or finish execution	

practical examples on threads
	if threads wait for each other -> synchronous communication
	if threads don't wait & run parallely -> asynchronous communication

Thread.sleep, wait, Thread.notifyAll, see other thread methods like join, priorities(1-10, 10 being the highest), yield, stop etc
synchronized keyword -> to make sure our threads run synchronously, dead lock scenario
s

Java 8 -> advanced Java :

	Lambda Expressions,
	Method References,
	Functional Interfaces,
	Stream API, 
	default methods,
	Optional.class,
	forEach,
	Collectors Class
	Date & Time changes

Functional Interface(FI) :
	Single Abstract Method (SAM)
	@FunctionalInterface -> extends other interface only if it has a single abstract method
		a FI can extend non-FI as well
		a FI can extend other FI
	(Bi)Consumer, (Bi)Predicate, (Bi)Function, Supplier	

05/08/24 :

Lambda Expressions : symbol ->
			To write clear anonymous functions on a SAM interfaces, we use lambda
			no need to write return keyword if you have single line of implementation, for multiple lines we have to use a return keyword in lambda.
			forEach -> lambda

Streams API : on any collection, to process data we use streams API

Predicate  : checks conditions just like your if condition, to filter values based on condition
	-> boolean test method
	-> negate
	-> test
Function	: takes and i/p and gives some o/p, to map/transform data input to out put	
	-> apply
	-> define data types in function
Consumer : accepts parameter and doesn't return anything.. printing, saving, processing data without expecting o/p
	-> accept
Supplier : no i/p only o/p, generate values
	-> get
UnaryOperator -> o/p and i/p type should be same
Bi -> two i/ps	

