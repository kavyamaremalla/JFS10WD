1. tasks from guvi end -> 10-15 tasks, module assessmemt (skill enhancement)
2. mini project, capstone project 
3. assessment

Java Full Stack --> 

backend & front end -> Java
data base -> you store your data (personal & confidential)

Intro to Java. -> web,mobile,desktop apps development,
platform independent -> runs on any OS
OOPS -> follows object oriented programming lang

JVM , JDK, JRE ->

JVM -> load, verfiy, execute code & provide runtime environment
JRE -> implementation of JVM.. libraries + files -> Sun Microsystems
JDK -> JRE + some other tools like javac, java etc..
	Open JDK vs Oracle/Amazon Corretto JDK..
	Javadoc, jar, javac, load java it has tools

JEP -> Java Enhancement Proposal..
	irregular -> Java 6 : 2007, Java 7 : 2011, Java 8 : 2014, Java 9 : 2017.. Java 22 : 2024
	LTS -> java 8, 11, 17, 21 (current lts version)
	every six months i.e., march & september.. minor versions non-lts versions..
	march 12 & sept had java 13.. 12 will be supported until 13 release..

backward compatability ->

Installation of Java & IDE.

	Install JDK -> Amazon Corretto, Oracle or any other provider.. Go with Java 11 or Java 17
		java -version in command prompt
	check environment & system variable -> path to your java.. add JAVA_HOME, also add in path if not present


task : run a java file in your local machine without using an IDE & with using IDE.

Install IDE -> eclipse or sts or IntelliJ or any other tool you wish..

Java Basics :

	class -> blueprint
	object -> car ==> attributes : weight, color., methods/functionx -> drive, brakes
 	
 	Variables : to store data values

 	 //local, global/instance, static

    int price = 700; //instance or global variable

    static int m = 100; // static variable -> memory allocated once when class is loaded in memory

    public static void main(String[] args) {

        Car car = new Car();

        car.price =90; //object-level or instance variable

        int x = 80; //local variable

//        price = 90;
         m = 90;
    }

   public void add(){
        int sum = 100; //local variable
        m = 999;
    }

 	Primitive Data types : byte, short, int, long, float, double, boolean, char
 		-> predefined, immutable, stored in stack memory, store single values

 	Non-primitive	-> stores multiple values, user-defined,  mutable, stored in heap memory
 		String, Array, Object etc

 	Wrapper Classes -> collection, generics, autoboxing -> primitive to wrapper, unboxing is vice versa
 		Integer, Double, Long, Float etc built on primitive data types
 			

 		String -> text in ->  "double quotes"  -> "100 Marks"
 		int -> whole numbers
 		float -> 110.09f
 		char -> character -> 'a' -> one alphabet in single quote
 		boolean -> true/false
 		double val = 190.09; -> 8 bytes of memory
        float flVal = 190.09f; -> 4bytes of memory
        long longVal = 198081893786387457L;; -> 8 bytes of memory
        byte byteVal = 0; -> -128 to 127
        short  shortVal = 100;

        Non-primitive Datatypes: String


 	compile time & run time -> compile == while writing the code, run-time -> when you run/execute the code.


 Type Casting -> converting from one data type to other data type
 
 Example :  Widening & Narrow Casting


        
    //byte < short < char < int < long < float < double

    widening:

        int myInt = 8;
        double myDoubValue = myInt; //Automatic casting

//        System.out.println(myInt);
//        System.out.println(myDoubValue);

	narrow

        double db1 = 9.67d;
        int intVal = (int) db1; // manual cast

        System.out.println(db1);
        System.out.println(intVal);

Operators : Arithmetic, assignment, comparison, logical, bitwise

	 int result = 100 + 700;
        
        String output = "Hi " + "Welcome"; -> concatenation/concatinate

        System.out.println(result);
        System.out.println(output);

     Postfix :
     
      int x = 1, j;
       j = x++;

        System.out.println(j + " " + x );


        logical operators:

      int age = 17;

        System.out.println(age > 18 && age < 100);//false
        System.out.println(age > 18 || age < 100);//true
        System.out.println(!(age > 18 || age < 100));//false   

        Scanner :

         Scanner scanner = new Scanner(System.in);

        System.out.println("Please enter your age ");

        int age = scanner.nextInt();
        

        System.out.println(age > 18 && age < 100);//false
        System.out.println(age > 18 || age < 100);//true
        System.out.println(!(age > 18 || age < 100));//false

Conditional/Control statements: after this terenary operator

Decision -> if/switch -> if, if-else, if & else if, nested if
loop -> while, do while, for, for-each
jump -> break, continue, return

18/07/24 : 

Debugging a class -> scanner and nested-if example.

Naming conventions :

	class -> start with capital letter -> upper camel case 
		SwitchCaseExample
	variable/function/ method name -> starts with small letter
		int age;
		public void sum(){}
	checking account balance method-> checkAccountBalance -> lower camel case
	car -> applyBrakesForCar

Switch :

import java.util.Scanner;

public class SwitchCaseExample {

    public static void main(String[] args) {

        Scanner scanner = new Scanner(System.in);

        System.out.println("Enter day in a week ");
//        char dayOfWeek = scanner.next().charAt(0);

        String dayOfWeek = scanner.next();

        switch (dayOfWeek){
            case "Monday" :
                System.out.println("Day 1");
                break;
            case "Tuesday" :
                add();
                System.out.println("Day 2");
                break;
            case "Wednesday" :
                System.out.println("Day 3");
                break; //keyword
            default:
                System.out.println("Please check your input");
        }


    }

    public static void add(){
        System.out.println("Inside add");
    }
}

For loop :

 System.out.println("Started for loop execution");

        for(int i = 5; i <10; i++){
            System.out.println(i);
        }

        System.out.println("For loop ended");

Nested-for :

    for(int i = 1; i <= 3; i++){ // 1, 2, 3
            for (int j = 1; j <= 3 ; j++) {
                System.out.println(i + " " + j); // 1 1 , 2, 3:::: 2 1 2 3 :::  3, 1, 2, 3
            }// ends i loop
        } // ends j loop        

 int i =3;

        System.out.println(i);
        System.out.println(i++);
        System.out.println(i);
        System.out.println(++i);


for-each/enhanced-for loop : to iterate over collections  


        int arr[] = {1,2,51,62,86,98};

        for(int i : arr){
            System.out.println(i);
        } 

int[] arrayOfNumbers = {1,2,51,62,86,98};

        for(int integerValue : arrayOfNumbers){
            System.out.println(integerValue);
        }


        System.out.println("*******************************************");

        for (int i=0; i < arrayOfNumbers.length ; i++){
            System.out.println(arrayOfNumbers[i]);
        }
 infinite for loop -> 
 
     for( ;  ; ){

            System.out.println("Inside for loop");
        }       

 while loop :
 
  int i = 1;

        while (i< 10){
            System.out.println(i);
            ++i;
        }

do-while loop:

 int i = 1;
       
       do{
           System.out.println(i);
           i++;
       }while (i<=10);


break, return & continue :

  public static void main(String[] args) {
        for (int i = 0; i <=10 ; i++) {
            if(i==5){
//                return;
//                continue;
                break;
            }
            System.out.println(i);
        }

        calculateEngineCC(20);
    }

    public static int calculateEngineCC(int weight){
        int capacity = weight * 1000;
        System.out.println(capacity);
        return capacity;
    }       


Ternary Operator :

 String result = age >= 18 ? "Eligible to vote"  : "Please check next time, not-eligible" ;

 Math Operations

 Literals -> Integer, Character, Boolean, String

 	int price = 750; // 750 -> literal

Main method:

    public static void main(String[] args) {
    }

    public -> to call this method from anywhere by JVM
    static -> can be called without creating an object of the class & memory will be allocated to this..
    void -> no return value to JVM
    main -> name of method
    String[] args -> one argument/parameter of type String array

Git : github, gitlab, bitbucket.. -> distributed version control system

	1. signup
	2. create a repository
	3. add files/folders

Bring from your github account to your local machine :	

git clone https://github.com/kavyamaremalla/JFS10WD.git

Add files to github account : Committing to git

	local ->  staging(temporary storage of files to be committed)  -> github account

git status -> file status 
git add <fileName which you want to send to github account> or for all files -> git add .
git commit -m "Your Message Here : Reason why you are committing" -> local to staging
git push -> from staging to github account

git pull -> changes from github  made by others to be in your local machine


Keywords
	void -> no return type
	static -> memory allocated first to this method

22/7/24 :
Arrays :
Create Arrays :

String[] carBrands = {"Volvo", "Hyundai", "Kia" , String.valueOf(7)};

Integer[] carPrice = {76, 89, 90, 12, Integer.parseInt("45")};

Read Ops on Array:

Index -> position of an element & starts with 0

    array[indexPosition] -> return element in that particular position

    carBrands[4] -> ArrayIndexOutOfBoundsException: Index 4 out of bounds for length 4

    carBrands.length -> length of the array (here it's 4)

    Read an array -> Arrays.toString(carBrands)

    for/for-each on array -> reads elements separately

Update ->

    nameOfArray[indexPositionToUpdate]  = updatedValue

Delete an element from array without conversion to array list.

Removing element from array & insert an element into array without using arraylist

create objects

    1. using new keyword
    2. using new instance
    3. using clone() method
    4. using deserialization
    5. using newInstance() of constructor class

23/07/24    

Access Modifiers -> public, private, protected, default
	- class, method, variables & constructors

package -> group of classes within same space

array sorting -> with and without in-built sort method	
array compares
array equals, fill

Strings : 

	 - charAt(), compareTo(), compareToIgnoreCase(), concat(),contains(), toLowerCase , toUpperCase, equals, endsWith, startsWith, matches, replaces, split, length, split,
	 subString -> string sequence ; subSequence -> CharSequence, toCharArray, toString, String.valueOf, trim

Task :  sort a string array using compareTo

24/07/24

regex, string pool, string builder & buffer, constructors

Regex -> Regular Expression

	. create gmail/email as i/p -> @gmail.com
	. pattern -> capCase, small case, spcl charc, some numbers, min length
		[A-Z], [a-z], [0-9], for not equal to ^ (cap)
		[aA0-zZ9]{3,5}@ -> combined, range
		\d -> decimal
		\D -> non-decimal
		\w -> like combined (decimal & non-deecimal)
		\W -> alpha-numeric
		. -> \w + \W
		.* -> repeatition
		.+ -> match anything

1. define a string pattern
2. compile the string to a regex
3. give i/p
4. match i/p & regex


String -> immutable class
String Builder & String Buffer -> mutable classes

string pool -> Java heap memory storage
	-> .equals checks only value of strings
	-> == checks reference/address/memory of strings

Constructor :
	to initialize the objects
	when you create an object of class, that class's constructor will be called -> default
	parameterized/argumented constructor -> when you send parameters
		-> pass any number of parameters
		-> this keyword

25/07/24:

Oops - Object Oriented Programming
	DRY, Don't Repeat Yourself principle -> reduce repetition of code -> boiler plate code

Encapsulation -> hiding sensitive data from users
	-> variables/methods/attributes will be defined as private
	-> public get and set methods to access and update the private variables

Inheritance(is-a relationship) : getting methods, variables from one class to other class
 	-> subclass (child class) :: the class inherits from another class
 	-> superclass (parent class) :: class which is being inherited
 	keyword -> extends
 	-> multiple inheritance -> one sub class trying to extend more than one super class
 		-> no, java doesn't support multiple inheritance
 			- Diamond problem
 			- complexity.. it should be simple and readable
 	-> can't inherit from a final class
 	Immutable -> other class can't modify attributes, methods etc in a class.
 		-> final keyword at class level -> no other class can extend this immutable class
 		-> declare variables as private and final, only you provide getters	and no setters are declared, provides constructor to initialize the variables
 		***** Once the object is initialized, it can't be modified!	******
	super keyword -> superclass(parent objects)
		-> calls constructor/methods/variables of parent class without creation of object to a parent class
	types : single, multi level, hierarchical, hybrid	

26/07/24 :

	SUPER keyword example -> Person & Employee

Polymorphism
	-> exists in many forms & it occurs when we have many classes that are related to each other by inheritance --> you can do a single action in multiple ways
		. compiletime polymorphism -> method overloading
		. run time polymorphism -> method overriding
	Method overriding -> during run time, jvm determines which method to call
		. from parent, you can create an object of sub class
		. can't override a static method
	@Override -> indicates that a method in a subclass is intended to override a method in parent class
		. if method is not present in parent, but in child if you put @Override it gives you compilation error
		. applicable only on methods not on variables/constructors
		. checks name of parent method and number & type of parameters.. to match with child class
		. improves readability
	Method Overloading -> during compile time, jvm determines which method to call
		. change input parameters data-type (instead of int, double)
		. change number of arguments passed	(instead of 2 int args, 3 int args)
			ambiguity -> if jvm can't determine the type 
				(int, double as i/p params for MethodA & double, int as i/p params for MethodB)
			
29/07/24

Abstraction	-> Data abstraction is called hiding the implementation/logic and showing the essential details
		1. using abstract class -> abstract keyword on classes/methods
			can have both abstract & non-abstract methods
			. class -> restricted class & can't be used to create objects (to use this, we have to inherit this class from another class)
			. method -> can be used only in abstract class and it doesn't have a body. The body will be provided its subclass(inherited class/child classs)
			. abstract is not available at variable level
		2. using interface
			-> completely follows abstract class but, related methods will have empty bodies
			-> implements keyword (child implements methods of parent)
			-> 100% abstraction can be achieved by interface because it doesn't show any logic in normal methods as well (not only abstract class)
			->	by default all methods in an interface are abstract and public.
			-> by default, a variable in an interface is static and final
			->	you can implement multiple interfaces

********* extends -> class level & implements -> interface level ************	
Multi level inheritance is not possible but multiple inhertiance using interface is possible

Enums : enumeration/enumerator

	-> group of constants, can't be changed just like final variables, enum(keyword) is a spcl class
	-> All constants are by default public, static, final

30/07/24 :

Association -> one-to-one, one-to-many, many-to-one, many-to-many relationships/mapping

Aggregation -> has-a relationship	
			bike(child) can exist independently, Vehicle as a parent can't exist independently

Composition : part-of (house and room, house is destroyed -> room will also be destroyed)		

Task : try to get practical example of Association, Aggregation & Composition

Exception handling : Exception hierarchy

technically, throw an exception -> when you expect some error in the program
	can't have multiple try blocks but can have multiple catch blocks -> in single try catch
	finally -> even if try/catch executes or not, this gets executed
	throw(line level) vs throws(method level) -> error handling 
Inbuilt Exception:
	checked vs unchecked -> 
		checked -> exceptions should be handled by user, don't extend runtimeexception
			FileNotFoundException
			throws -> at method level, the method which calls the throws method expects to handle exception either by writing try-catch block or throws exception
				-> suggested to use try-catch
		unchecked -> exceptions jvm handles, these extend runtimeexception
			ArithmeticException

Custom Exception/User-defined exception : we create our own exception
	1. extends exception
	2. calling Parent's constructor from child(user defined exp class) constructor

Collections : framework of Java, which stores/manipulates group of objects.. Collection means a single unit of objects
	-> Book/Coin Collection
	-> it provides interfaces(List, Set, Queue, Dequeue, Map) & classes to perform data operations

Hierarchy : 
Iterable (interface) -> Collection(Interface)
				Under collec -> List (interface) : linkedlist, arraylist..
							-> Queue (interface) -> Dequeue(interface)
							-> Set(interface) -> Sorted set(interface)
							-> Map (interface)
							-> stack
List 

	ArrayList
	-> array vs arrayList : 
		. create an arrayList
		. add elements
		. allows duplicates
		. read using for each loop
		. convert array to list and list to array
		. follows insertion order
		. Collections.sort(nameOfList)	
		. size of arraylist
		. contains -> search an object in an arrayList	
		. remove(index number)	
		. clear / removeAll 
		. add object at particular index position	
		. allows null elements

	Linked List
		. creation
		. adding elements
		. print elements in list using iterator

  //loose coupling & tight coupling
  hash & toString.

  	HashSet -> follows hashing mechanism	
  		. creating & adding elements
  		. allows null values
  		. unique elements, no duplicates
  		. no insertion order, based on hash of objects it inserts & displays the values
  		. removeIf, remove, removeAll
  	LinkedHashSet 
  		. no duplicates allowed
  		. insertion order	
  	TreeSet	
  		. ascending order
  		. no duplicates
  		. no null values allowed
  		. uses comparable, only the comparable objects are allowed
Queue & Priority Queue :	
		. FIFO -> First In First Out
		. create & adding elements to queue
		. read queue
		. stores in ascending order, allows duplicates
		. doesn't allow null
		. pull, element, remove, add, peek

Deque & Array Deque : Double ended queue
		. LIFO -> Last In First Out	 & FIFO -> First In First Out
		. we can add/remove elements from both sides
		. insertion order
		. null values not allowed
		. duplicates are allowed
		. pollFirst, pollLast, removeFirst, removeLast, addFirst, addLast

Stack :
		. LIFO -> Last In First Out		
		. push & pop, top
		. insertion order
		. duplicates & null values are allowed
		. remove, removeAt, add, addAt etc

Map : stores elements on form of key, value pairs called entries.

put, remove, keySet, entrySet, get(key) = value, map.values(), contains, isEmpty, size, replace

	hashMap: internal working of a hashmap

	. keys and values pair
	. no order, based on hashing it gives result
	. duplicates keys are not allowed, duplicate values can be allowed
	. you can update value while creation itself
	. allows null key and null values

	linkedHashMap -> Map + hashmap : allows null key and null values, follows insertion order

	TreeMap -> Map + sorted map : doesn't allow any null keys and null values.

02/08/24 :

toString, hashcode and equals

	toString -> every obj inherits this method through Object.java
	returns string rep of an object
	returns hash of the object

	hashCode -> memory of object

	equals -> override hash and equals

Multithreading :

thread -> extending thread & implementing Runnable/Callable

thread life cycle -> new, run, -> either wait/sleep or finish execution	

practical examples on threads
	if threads wait for each other -> synchronous communication
	if threads don't wait & run parallely -> asynchronous communication

Thread.sleep, wait, Thread.notifyAll, see other thread methods like join, priorities(1-10, 10 being the highest), yield, stop etc
synchronized keyword -> to make sure our threads run synchronously, dead lock scenario
s

Java 8 -> advanced Java :

	Lambda Expressions,
	Method References,
	Functional Interfaces,
	Stream API, 
	default methods,
	Optional.class,
	forEach,
	Collectors Class
	Date & Time changes

Functional Interface(FI) :
	Single Abstract Method (SAM)
	@FunctionalInterface -> extends other interface only if it has a single abstract method
		a FI can extend non-FI as well
		a FI can extend other FI
	(Bi)Consumer, (Bi)Predicate, (Bi)Function, Supplier	

05/08/24 :

Lambda Expressions : symbol ->
			To write clear anonymous functions on a SAM interfaces, we use lambda
			no need to write return keyword if you have single line of implementation, for multiple lines we have to use a return keyword in lambda.
			forEach -> lambda

Streams API : on any collection, to process data we use streams API
			-> forEach & filter on a stream

Types of FI :

Predicate  : checks conditions just like your if condition, to filter values based on condition
	-> boolean test method
	-> negate
	-> test
Function: takes and i/p and gives some o/p, to map/transform data input to out put	
	-> apply
	-> define data types in function
Consumer : accepts parameter and doesn't return anything.. printing, saving, processing data without expecting o/p
	-> accept
Supplier : no i/p only o/p, generate values
	-> get
UnaryOperator -> o/p and i/p type should be same
Bi -> two i/ps	

IntPredicate, DoubleSupplier etc ->  you can define i/p & o/p for those predefined datatypes.

06/08/24 :

 -> Arrays.asList(define values here), you can't perform add.. unmodifiable list
 -> .collect(Collectors.toList()), toList();
 -> map(function)
 -> Collections.reverseOrder, sort collections
 -> min value, max value
 -> Optional class -> if you are not sure if the result is present or not.
 	-> get, comparator, isPresent, isEmpty, orElse

Streams.reduce -> try to read about this

Method References : you can replace your lambda with method references, applicable on FI only
	1. reference to a static method
	2. ref. to constructor
	3. ref. to an instance/non-static method 	
Practical examples for all above

Callable -> similar to Runnable.. Callable returns result & throws a checked exception if it couldnot find the result.
Future -> async computation's result
    -> single task execution & blocking (block result and proceed) 
        Ex : fetching data from remote server

07/08/2024 :

    Completable Future  -> Future + Completion Stage 
     Completable Future -> implementation of future with some additional asynch method computations.
     Completion Stage -> responsible for asynch communication
        ->nonblocking, chaining & composition(asynch data processing pipeline)

Private methods in interface
    -> as part of Java 8, we have default & static keywords/methods in an interface, by default all methods are public

    -> private methods can't be abstract
    -> only in other methods of that particular interface, you can call private methods
    -> pvt static method can be used inside other static methods 
    -> pvt non-static methods can be used in any other static/default methods in interface

-> here common methods in two interfaces problem can be overcomed by calling the super method using interface name
    
    @Override
    public void method2() {
        CustomInterface.super.method2();
    }

Var keyword -> common datatype for all values, JC(java compiler) will determine the type of data based on value of data.

    var age = 7.02d;

    var name = "John";

    var map =new HashMap<String, Integer>(); // applicable to all collections

   Drawbacks :
   
    int x ;  x = 10;

   1. var y ; y = 15; -> compilation error
   2. can't use this as a global variable, method parameter, return type
   3. can't assign null as value


Text blocks from Java 10-> replaces \n with """ quotes. 

Records from Java 14 -> parameterized constructor, getter, toString, hash and equals
    By default these records are immutable

entity or POJO -> Plain Old Java Object/ DTO -> Data Transfer Object    

08/08/24:

Collectors API & Immutable Collections : from Java 9

    -> Collections.unmodifyableList -> allow null values
        can modify your original collection
    -> List.of/Map.of/Map.ofEntries --> immutable collections -> no null values allowed
        can't modify, only read/search

-> Stream.of/Stream.ofNullable/takeWhile/dropWhile

Switch expressions -> Java 13 & 14, we have yield..

    -> yield, some logic before yield
    -> lambda replacement of yield & logic and multiple statements with lambda & yield

Date & Time API : LocalDate, LocalTime, LocalDateTime, DateTimeFormatter
More examples of Patterns -> HH, MM, ss, yyyy, dd, mm etc
    https://howtodoinjava.com/java/date-time/java8-datetimeformatter-example/

    ZonedDateTime
    LocalDateTime conversions
    ChronoUnit
    Period -> deals with date
    Duration -> deals with time

    Negative : start < end
    Zero : start = end
    Positive : start > end

    Temporal Adjusters & Instant -> read about these

09/08/24 :

file handling

    check if file exists or not using fileName
    if file doesn't exist, we created a file, read contents from file, updated contents, replaced contents
    If file name already exists and if we create another file using same name in same directory it gives run time exception.

 try with resources
 AutoCloseable

sealed and non-sealed

    sealed -> can be extened only by sub classes that are defined by permits keyword
    non-sealed -> a subclass of a sealed class which is open for extension
    final -> can't extend by any other class

CodeKata & WebKata -> how to solve  

12/08/24 :  

Types of Classes :

    static, final, inner class, pojo class, singleton class, abstract class, concrete class etc

generics : parameterized types, to allow any type of object
T - type
E - element
K - key
N - number
V - value

use cases of generics : code resue and type safety

Comparable and comparator

read about garbage collection, finalize in GC and memory allocation in jvm

13/08/24:

HTML -> Hyper Text Markup Language

VS code installation, setup, download extensions, creating files/folders.

html tags/elements -> for formatting and displaying content on a web page
    -> opening tag(<button>), content, closing tag(<button/>)
    -> unclosed tags(<br content/>, <hr>)

html -> root for html page
head -> info about document just like import in java
body -> content you show in your website

attributes in your opening tag-> lang="en"    

<title> name for your web page

Header tags :

<h1 to h6 id="heading"> content here <h1 to h6/>
<p> -> paragraph
<hr> -> horizontal line
<pre> -> display content with spaces and line changes

Inline CSS -> inside the start tag

Styles -> font-family,Font-size -> 100% -> 16px
Colors -> text clr, bg clr, rgb(red, green, blue), hexadecimal(hex), hsl and hsla(hue, saturation, lightness, alpha)
    hue -> 0 to 360
    sat, lightness -> 0 to 100%
    alpha -> 0.0 to 1.0

Anchor tag : Links/Buttons etc

    <a href="https://facebook.com">Visit our official facebookpage</a> <br />
    <a href="mailto:test@gmail.com">Contact us here</a> <br />
    <a href="mailto:test@gmail.com" title="Mail Us">Contact through mail</a>
    <!-- tool tip --><br />
    <a href="https://facebook.com" target="_blank">Visit in new tab</a>

img -> Image tag : absolute url(external links to images) or relative url(inside your folder)

<img src="image path" alt="alternate text">    
<img src="images/bridge.jpg" alt="A bridge image" style="width: 500px; height: 600px;">
<img src="images/mountains.jpg" width="500" height="600">
style -> float:right -> aligning your image
add link to an image -> inside anchor tag you will place your image
background image : url() and ctrl this image

internal css -> <style> tag

14/08/24 :

picture -> based on screen size we can change images

Formatting :
<b>, <i>, <strong>, <em>, <mark>, <del>, <sub>, <sup>, <ins>

Quotation and Citing :

<blockquote cite="yourwebsite">
<address>
<abbr> -> abbrevations

favicons : logo of our website near title
 <head> 
    <link rel="icon" type="image/x-icon" href="images/bridge.jpg">
  </head>

Inline CSS, Internal CSS, External CSS

<link rel="stylesheet" href="styles.css">  --> external CSS

Border : space around html element
padding : space btwn text and border
margin : space around border

Tables :
<table>
<th>
<tr>
<td>
horizontal headers, vertical headers
colspan
rowspan
height, width, table properties
caption -> table name

Lists :

unordered -> ul -> disc, circle, square, none, nested list
ordered -> ol -> type = a, A, 1, i, I and start = number/letter, nested list
descriptive -> dl -> dd, dt

developed a nav bar from ul, we used property called float

16/08/24 :

div : container and for styling page elements, block-level code
    float, div class, display :inline-block, flex, grid
span : line level/in-line container

block line -> p , div etc
inline -> span, a etc

when you use class in any tag, style with .className to style
when you use id in any tag, style #idName to style

Generally we maintain single id in a html page and multiple classes


Layouts : float, flex, grid

semantic tags : header, footer, nav, section, article, aside, details, summmary, form, table etc

header -> define a header for doc
nav -> navigation links
footer -> meta information

Forms : takes input from user and sends to server or backend for processing
    label -> for, value -> placeholder
    input -> diff types of i/p, id to map with label, value -> placeholder
    attributes -> action, target, method (get by default and post -> secured), autocomplete
    novalidate

 19/08/24:
 
 Forms : 
    elements : select, option, selected, size, multiple
    <textarea name="message" rows="10" cols="30">Please leave message here</textarea> <br>
    <textarea name="message" style="width: 200px; height: 600px;">Please leave message here</textarea> <br>
    legend, fieldset, input as list and datalist with options
    alert
    input types : date, datetime, color etc
    i/p restrictions : min, max, size, pattern, placeholder, required
    readonly, disabled, multiple

box model -> design and layout
    content, padding, border, margin

Selectors : # -> id
            . -> class
            simple, universal (*), grouping selector..
   
Dropdowns : position, box-shadow, display, hover, zindex, right, left,cursor: pointer;
   